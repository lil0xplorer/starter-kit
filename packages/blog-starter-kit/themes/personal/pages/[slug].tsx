import { resizeImage } from '@starter-kit/utils/image';
import { addEnhancedArticleJsonLd, addWebsiteJsonLd } from '@starter-kit/utils/seo/enhancedJsonLd';
import { generateMetaDescription, generateMetaKeywords } from '@starter-kit/utils/seo/contentUtils';
import { getAutogeneratedPostOG } from '@starter-kit/utils/social/og';
// @ts-ignore
import handleMathJax from '@starter-kit/utils/handle-math-jax';
import { useEmbeds } from '@starter-kit/utils/renderer/hooks/useEmbeds';
import { loadIframeResizer } from '@starter-kit/utils/renderer/services/embed';
import request from 'graphql-request';
import { GetStaticProps } from 'next';
import Head from 'next/head';
import Link from 'next/link';
import { useEffect, useState } from 'react';
import { Breadcrumb } from '../components/breadcrumb';
import { Container } from '../components/container';
import { AppProvider } from '../components/contexts/appContext';
import { CoverImage } from '../components/cover-image';
import { DateFormatter } from '../components/date-formatter';
import { Footer } from '../components/footer';
import { Layout } from '../components/layout';
import { MarkdownToHtml } from '../components/markdown-to-html';
import { Meta } from '../components/meta';
import { OptimizedImage } from '../components/optimized-image';
import { PersonalHeader } from '../components/personal-theme-header';
import { ReadingTime } from '../components/reading-time';
import { SocialShare } from '../components/social-share';
import {
	PageByPublicationDocument,
	PostFullFragment,
	PublicationFragment,
	SinglePostByPublicationDocument,
	SlugPostsByPublicationDocument,
	StaticPageFragment,
} from '../generated/graphql';
// @ts-ignore
import { triggerCustomWidgetEmbed } from '@starter-kit/utils/trigger-custom-widget-embed';

type PostProps = {
	type: 'post';
	post: PostFullFragment;
	publication: PublicationFragment;
};

type PageProps = {
	type: 'page';
	page: StaticPageFragment;
	publication: PublicationFragment;
};

type Props = PostProps | PageProps;

const Post = ({ publication, post }: PostProps) => {
	const highlightJsMonokaiTheme =
		'.hljs{display:block;overflow-x:auto;padding:.5em;background:#23241f}.hljs,.hljs-subst,.hljs-tag{color:#f8f8f2}.hljs-emphasis,.hljs-strong{color:#a8a8a2}.hljs-bullet,.hljs-link,.hljs-literal,.hljs-number,.hljs-quote,.hljs-regexp{color:#ae81ff}.hljs-code,.hljs-section,.hljs-selector-class,.hljs-title{color:#a6e22e}.hljs-strong{font-weight:700}.hljs-emphasis{font-style:italic}.hljs-attr,.hljs-keyword,.hljs-name,.hljs-selector-tag{color:#f92672}.hljs-attribute,.hljs-symbol{color:#66d9ef}.hljs-class .hljs-title,.hljs-params{color:#f8f8f2}.hljs-addition,.hljs-built_in,.hljs-builtin-name,.hljs-selector-attr,.hljs-selector-id,.hljs-selector-pseudo,.hljs-string,.hljs-template-variable,.hljs-type,.hljs-variable{color:#e6db74}.hljs-comment,.hljs-deletion,.hljs-meta{color:#75715e}';
	const [, setMobMount] = useState(false);
	const [canLoadEmbeds, setCanLoadEmbeds] = useState(false);
	useEmbeds({ enabled: canLoadEmbeds });
	
	// Generate enhanced meta information
	const postDescription = post.seo?.description || post.subtitle || post.brief || 
		generateMetaDescription(post.content.markdown);
	const postTags = (post.tags ?? []).map((tag) => tag.name);
	const postKeywords = generateMetaKeywords(post.content.markdown, postTags);
	
	const tagsList = (post.tags ?? []).map((tag) => (
		<li key={tag.id}>
			<Link
				href={`/tag/${tag.slug}`}
				className="block rounded-full border px-2 py-1 font-medium hover:bg-slate-50 dark:border-neutral-800 dark:hover:bg-neutral-800 md:px-4"
			>
				#{tag.slug}
			</Link>
		</li>
	));

	if (post.hasLatexInPost) {
		setTimeout(() => {
			handleMathJax(true);
		}, 500);
	}

	useEffect(() => {
		if (screen.width <= 425) {
			setMobMount(true);
		}

		if (!post) {
			return;
		}

		// TODO:
		// More of an alert, did this below to wrap async funcs inside useEffect
		(async () => {
			await loadIframeResizer();
			triggerCustomWidgetEmbed(post.publication?.id.toString());
			setCanLoadEmbeds(true);
		})();
	}, [post]);

	const coverImageSrc = !!post.coverImage?.url
		? resizeImage(post.coverImage.url, {
				w: 1600,
				h: 840,
				c: 'thumb',
		  })
		: undefined;

	// Enhanced Open Graph image
	const ogImage = post.ogMetaData?.image || 
		post.coverImage?.url || 
		getAutogeneratedPostOG(post, publication);

	return (
		<>
			<Head>
				{/* Enhanced Article Schema */}
				<script
					type="application/ld+json"
					dangerouslySetInnerHTML={{
						__html: JSON.stringify(addEnhancedArticleJsonLd(publication, post)),
					}}
				/>
				
				{/* Website Schema */}
				<script
					type="application/ld+json"
					dangerouslySetInnerHTML={{
						__html: JSON.stringify(addWebsiteJsonLd(publication)),
					}}
				/>
				
				{/* Syntax highlighting theme */}
				<style dangerouslySetInnerHTML={{ __html: highlightJsMonokaiTheme }}></style>
				
				{/* Preload critical resources */}
				{coverImageSrc && (
					<link rel="preload" as="image" href={coverImageSrc} />
				)}
			</Head>
			
			{/* Enhanced Meta component with all SEO data */}
			<Meta
				title={post.seo?.title || post.title}
				description={postDescription}
				image={ogImage}
				canonicalUrl={post.url}
				keywords={postKeywords}
				author={post.author?.name}
				publishedTime={post.publishedAt}
				modifiedTime={post.updatedAt || undefined}
				section={post.tags?.[0]?.name}
				tags={postTags}
				type="article"
				twitterCreator={undefined} // socialMediaLinks not in current schema
			/>
			
			{/* Breadcrumb navigation */}
			<Breadcrumb />
			
			<article itemScope itemType="https://schema.org/BlogPosting">
				{/* Article title with proper heading structure */}
				<header className="mb-8">
					<h1 
						className="text-4xl font-bold leading-tight tracking-tight text-black dark:text-white mb-4"
						itemProp="headline"
					>
						{post.title}
					</h1>
					
					{/* Article metadata */}
					<div className="flex flex-wrap items-center gap-4 text-neutral-600 dark:text-neutral-400">
						<div className="flex items-center gap-2">
							<time 
								dateTime={post.publishedAt}
								itemProp="datePublished"
							>
								<DateFormatter dateString={post.publishedAt} />
							</time>
							{post.updatedAt && post.updatedAt !== post.publishedAt && (
								<>
									<span>•</span>
									<span className="text-sm">
										Updated: <time 
											dateTime={post.updatedAt}
											itemProp="dateModified"
										>
											<DateFormatter dateString={post.updatedAt} />
										</time>
									</span>
								</>
							)}
						</div>
						<span>•</span>
						<ReadingTime content={post.content.markdown} />
						{post.responseCount > 0 && (
							<>
								<span>•</span>
								<span>{post.responseCount} responses</span>
							</>
						)}
					</div>
					
					{/* Author info */}
					<div className="mt-4" itemProp="author" itemScope itemType="https://schema.org/Person">
						<span className="sr-only">Author: </span>
						<span itemProp="name">{post.author?.name}</span>
					</div>
				</header>
				
				{/* Cover image with optimization */}
				{!!coverImageSrc && (
					<div className="w-full mb-8" itemProp="image" itemScope itemType="https://schema.org/ImageObject">
						<OptimizedImage 
							src={coverImageSrc}
							alt={post.title} // coverImage.attribution not in current schema
							priority={true}
							className="w-full h-auto rounded-lg"
							width={1600}
							height={840}
							placeholder="blur"
						/>
						<meta itemProp="url" content={coverImageSrc} />
						<meta itemProp="width" content="1600" />
						<meta itemProp="height" content="840" />
					</div>
				)}
				
				{/* Article content */}
				<div itemProp="articleBody">
					<MarkdownToHtml contentMarkdown={post.content.markdown} />
				</div>
				
				{/* Social sharing */}
				<div className="my-8 py-6 border-t border-neutral-200 dark:border-neutral-800">
					<SocialShare 
						url={post.url}
						title={post.title}
						description={postDescription}
					/>
				</div>
				
				{/* Article tags */}
				{(post.tags ?? []).length > 0 && (
					<footer className="mx-auto w-full text-slate-600 dark:text-neutral-300 md:max-w-screen-md">
						<h3 className="text-lg font-semibold mb-4">Tags</h3>
						<ul className="flex flex-row flex-wrap items-center gap-2" itemProp="keywords">
							{tagsList}
						</ul>
					</footer>
				)}
				
				{/* Hidden schema.org properties */}
				<meta itemProp="wordCount" content={post.content.markdown.split(/\s+/).length.toString()} />
				<meta itemProp="url" content={post.url} />
				{/* Series support not available in current schema */}
			</article>
		</>
	);
};

const Page = ({ page, publication }: PageProps) => {
	const pageDescription = generateMetaDescription(page.content.markdown);
	
	return (
		<>
			<Meta
				title={page.title}
				description={pageDescription}
				canonicalUrl={`${publication.url}/${page.slug}`}
				type="website"
			/>
			
			<Breadcrumb />
			
			<article itemScope itemType="https://schema.org/WebPage">
				<header className="mb-8">
					<h1 
						className="text-4xl font-bold leading-tight tracking-tight text-black dark:text-white"
						itemProp="headline"
					>
						{page.title}
					</h1>
				</header>
				
				<div itemProp="mainContentOfPage">
					<MarkdownToHtml contentMarkdown={page.content.markdown} />
				</div>
				
				{/* Hidden schema.org properties */}
				<meta itemProp="url" content={`${publication.url}/${page.slug}`} />
			</article>
		</>
	);
};

export default function PostOrPage(props: Props) {
	const maybePost = props.type === 'post' ? props.post : null;
	const maybePage = props.type === 'page' ? props.page : null;
	const publication = props.publication;

	return (
		<AppProvider publication={publication} post={maybePost} page={maybePage}>
			<Layout>
				<Container className="mx-auto flex max-w-3xl flex-col items-stretch gap-10 px-5 py-10">
					<PersonalHeader />
					<main className="flex flex-col items-start gap-10 pb-10">
						{props.type === 'post' && <Post {...props} />}
						{props.type === 'page' && <Page {...props} />}
					</main>
					<Footer />
				</Container>
			</Layout>
		</AppProvider>
	);
}

type Params = {
	slug: string;
};

export const getStaticProps: GetStaticProps<Props, Params> = async ({ params }) => {
	if (!params) {
		throw new Error('No params');
	}

	const endpoint = process.env.NEXT_PUBLIC_HASHNODE_GQL_ENDPOINT;
	const host = process.env.NEXT_PUBLIC_HASHNODE_PUBLICATION_HOST;
	const slug = params.slug;

	const postData = await request(endpoint, SinglePostByPublicationDocument, { host, slug });

	if (postData.publication?.post) {
		return {
			props: {
				type: 'post',
				post: postData.publication.post,
				publication: postData.publication,
			},
			revalidate: 1,
		};
	}

	const pageData = await request(endpoint, PageByPublicationDocument, { host, slug });

	if (pageData.publication?.staticPage) {
		return {
			props: {
				type: 'page',
				page: pageData.publication.staticPage,
				publication: pageData.publication,
			},
			revalidate: 1,
		};
	}

	return {
		notFound: true,
		revalidate: 1,
	};
};

export async function getStaticPaths() {
	const data = await request(
		process.env.NEXT_PUBLIC_HASHNODE_GQL_ENDPOINT,
		SlugPostsByPublicationDocument,
		{
			first: 10,
			host: process.env.NEXT_PUBLIC_HASHNODE_PUBLICATION_HOST,
		},
	);

	const postSlugs = (data.publication?.posts.edges ?? []).map((edge) => edge.node.slug);

	return {
		paths: postSlugs.map((slug) => {
			return {
				params: {
					slug: slug,
				},
			};
		}),
		fallback: 'blocking',
	};
}
