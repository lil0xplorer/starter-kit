import { InferGetStaticPropsType } from 'next';
import { WithUrqlProps, initUrqlClient } from 'next-urql';
import Head from 'next/head';
import Image from 'next/legacy/image';
import { useState } from 'react';
import { twJoin } from 'tailwind-merge';
import { useQuery } from 'urql';

import { addPublicationJsonLd } from '@starter-kit/utils/seo/addPublicationJsonLd';
import { getAutogeneratedPublicationOG } from '@starter-kit/utils/social/og';
import { AppProvider } from '../components/contexts/appContext';
import { Header } from '../components/header';
import { Layout } from '../components/layout';
import ModernLayoutPosts from '../components/modern-layout-posts';
import SEO from '../components/SEO';
import {
	HomePageInitialDocument,
	HomePageInitialQueryVariables,
	HomePagePostsDocument,
	HomePagePostsQueryVariables,
} from '../generated/graphql';
import { createHeaders, createSSRExchange, getUrqlClientConfig } from '../lib/api/client';

import FeaturedPosts from '../components/features-posts';

import PublicationFooter from '../components/publication-footer';
import PublicationMeta from '../components/publication-meta';
import { resizeImage } from '../utils/image';

const REVALIDATION_INTERVAL_POST_VIEWS_ACTIVE = 60 * 60; // 1 hour
const REVALIDATION_INTERVAL = 60 * 60 * 24 * 30; // 1 month

const NoPostsImage = ({ alt = '' }) => {
	return (
		<Image
			alt={alt}
			height={500}
			width={500}
			src={resizeImage(
				'https://cdn.hashnode.com/res/hashnode/image/upload/v1625676910594/d1jtXmfQC.png?auto=compress',
				{ h: 800, w: 800, c: 'thumb' },
			)}
		/>
	);
};

export default function Index(
	props: InferGetStaticPropsType<typeof getStaticProps> & Required<WithUrqlProps>,
) {
	const { host, publication, initialLimit } = props;

	const ssrCache = createSSRExchange();
	// @ts-ignore - Temporary ignore for urql version compatibility issue
	const urqlClient = initUrqlClient(getUrqlClientConfig(ssrCache), false); // TODO: Check why is urqlClient not automatically being passed in props. Ideally, since we are using WithUrqlClient HOC, it should automatically come

	const [fetching, setFetching] = useState(false);

	const { author, preferences, pinnedPost } = publication;
	const dynamicLimit = preferences.layout === 'magazine' ? 12 : 6;

	const [{ data }] = useQuery({
		query: HomePagePostsDocument,
		variables: { host, first: initialLimit, filter: { excludePinnedPost: !!pinnedPost } },
	});

	const { posts } = data?.publication!;

	const fetchedOnce = posts.edges.length > initialLimit;

	const postsToBeRendered = {
		edges: pinnedPost
			? [{ node: pinnedPost, cursor: `${pinnedPost.id}_${pinnedPost.publishedAt}` }].concat(
					posts.edges,
			  )
			: posts.edges,
		pageInfo: posts.pageInfo,
	};

	const fetchMore = async () => {
		setFetching(true);
		await urqlClient
			.query(HomePagePostsDocument, {
				host,
				first: dynamicLimit,
				after: posts.pageInfo.endCursor,
				filter: { excludePinnedPost: !!pinnedPost },
			})
			.toPromise()
			.finally(() => {
				setFetching(false);
			});
	};

	return (
		<AppProvider publication={publication}>
			<Layout>
				{/* 
				SEO Component Usage Example:
				Replace the Head section below with the reusable SEO component.
				This demonstrates how to use the SEO component with Hashnode publication data.
				*/}
				<SEO
					title={publication.displayTitle || publication.title || 'Hashnode Blog Starter Kit'}
					description={
						publication.descriptionSEO || publication.title || `${publication.author.name}'s Blog`
					}
					url={`https://${process.env.NEXT_PUBLIC_HASHNODE_PUBLICATION_HOST || 'localhost'}`}
					image={publication.ogMetaData.image || getAutogeneratedPublicationOG(publication)}
					siteName={publication.title}
					// Note: Twitter handle would come from publication.links.twitter if available
					twitterHandle={publication.links?.twitter?.replace('https://twitter.com/', '').replace('@', '')}
					keywords={publication.author.name ? [publication.author.name] : []}
					structuredData={addPublicationJsonLd(publication)}
				/>
				
				{/* Header with semantic HTML structure */}
				<Header isHome={true} />
				
				{/* Main content area with semantic HTML */}
				<main>
					{/* Featured posts section */}
					{postsToBeRendered.edges.length > 0 && (
						<section aria-label="Featured posts">
							<FeaturedPosts
								posts={postsToBeRendered.edges.map((p: any) => p.node).slice(0, 3)}
								publication={publication}
							/>
						</section>
					)}

					{/* Publication about section */}
					{publication.about?.html && (
						<section 
							className="blog-author-container border-b dark:border-slate-800"
							aria-label="About this publication"
						>
							<div
								className={twJoin(
									'blog-author-area feed-width mx-auto md:w-3/4 lg:w-2/3',
									preferences.layout === 'grid' ? '' : 'px-4 lg:px-8',
								)}
							>
								<PublicationMeta
									author={author}
									aboutHTML={publication.about.html}
									isTeam={publication.isTeam}
								/>
							</div>
						</section>
					)}

					{/* No posts message with semantic structure */}
					<section className="blog-content-area feed-width mx-auto md:w-2/3">
						{postsToBeRendered.edges.length === 0 && (
							<div className="min-h-30 my-10 flex w-full flex-col items-center px-6 dark:border-slate-800">
								<div className="block">
									<NoPostsImage alt="No Posts Available" />
								</div>
								<h2 className="sr-only">No Posts Available</h2>
								<p className="sr-only">There are currently no posts published on this blog.</p>
							</div>
						)}
					</section>

					{/* Recent posts section */}
					{postsToBeRendered.edges.length > 3 && (
						<section aria-label="Recent posts">
							<ModernLayoutPosts
								publication={publication}
								posts={postsToBeRendered}
								fetchMore={fetchMore}
								fetchedOnce={fetchedOnce}
								fetching={fetching}
							/>
						</section>
					)}
				</main>
				
				{/* Footer with semantic HTML */}
				{publication && (
					<PublicationFooter
						authorName={publication.author.name}
						title={publication.title}
						imprint={publication.imprint}
						disableFooterBranding={publication.preferences.disableFooterBranding}
						isTeam={publication.isTeam}
						logo={publication.preferences.logo}
						darkMode={publication.preferences.darkMode}
					/>
				)}
			</Layout>
		</AppProvider>
	);
}

export const getStaticProps = async () => {
	const ssrCache = createSSRExchange();
	// @ts-ignore - Temporary ignore for urql version compatibility issue
	const urqlClient = initUrqlClient(getUrqlClientConfig(ssrCache), false);
	const host = process.env.NEXT_PUBLIC_HASHNODE_PUBLICATION_HOST;
	const homePageInitialQueryVariables: HomePageInitialQueryVariables = {
		host,
	};
	const publicationInfo = await urqlClient
		.query(HomePageInitialDocument, homePageInitialQueryVariables, {
			fetchOptions: {
				headers: createHeaders({ byPassCache: false }),
			},
			requestPolicy: 'network-only',
		})
		.toPromise();

	if (publicationInfo.error) {
		console.error('Error while fetching publication info', {
			variables: homePageInitialQueryVariables,
			error: publicationInfo.error,
		});
		throw publicationInfo.error;
	}
	if (!publicationInfo.data?.publication) {
		console.error('Publication not found fetching publication info; returning 404', {
			variables: homePageInitialQueryVariables,
		});
		return {
			notFound: true,
			revalidate: REVALIDATION_INTERVAL,
		};
	}

	const { publication } = publicationInfo.data;

	const subtractValue = publication.pinnedPost ? 1 : 0;
	const initialLimit =
		publication.preferences.layout === 'magazine' ? 12 - subtractValue : 6 - subtractValue;

	const homePagePostsVariables: HomePagePostsQueryVariables = {
		host,
		first: initialLimit,
		filter: { excludePinnedPost: !!publication.pinnedPost },
	};
	const homePagePostsResponse = await urqlClient
		.query(HomePagePostsDocument, homePagePostsVariables, {
			fetchOptions: {
				headers: createHeaders({ byPassCache: false }),
			},
			requestPolicy: 'network-only',
		})
		.toPromise();
	if (homePagePostsResponse.error) {
		console.error('Error while fetching home page posts', {
			error: homePagePostsResponse.error,
			variables: homePagePostsVariables,
		});
		throw homePagePostsResponse.error;
	}
	if (!homePagePostsResponse.data?.publication) {
		console.error('Publication not found fetching home page posts; returning 404', {
			variables: homePagePostsVariables,
		});
		return {
			notFound: true,
			revalidate: REVALIDATION_INTERVAL,
		};
	}

	return {
		props: {
			publication,
			initialLimit,
			urqlState: ssrCache.extractData(),
			host,
			isHome: true,
		},
		revalidate: 1,
	};
};
